
'use client';

import { create } from 'zustand';
import { toast } from './use-toast';
import { SupabaseClient } from '@supabase/supabase-js';

export interface Payment {
    date: string;
    amount: number;
    method: 'efectivo' | 'tarjeta' | 'transferencia';
    cash_received?: number | null;
    change_given?: number | null;
}

export interface Address {
  department: string;
  municipality: string;
  colony?: string;
  exactAddress: string;
}

// Corresponds to the `orders` table in Supabase
export interface Order {
  id: string; // uuid from Supabase
  display_id: string;
  created_at: string;
  user_id: string | null;
  customer_id: string | null;
  customer_name: string;
  customer_phone: string;
  customer_address: Address | null;
  items: Array<{
    id: string;
    name: string;
    price: number;
    quantity: number;
    image: string;
  }>;
  total: number;
  shipping_cost: number;
  balance: number; 
  payments: Payment[]; 
  payment_method: 'efectivo' | 'tarjeta' | 'transferencia' | 'credito';
  payment_reference: string | null;
  status: 'pending-approval' | 'pending-payment' | 'paid' | 'cancelled';
  source: 'pos' | 'online-store';
  delivery_method: 'pickup' | 'delivery' | null;
  payment_due_date: string | null;
}

// Type for creating a new order, without the fields generated by the DB
export type NewOrderData = Omit<Order, 'id' | 'display_id' | 'created_at' | 'customer_id'>;

type OrdersState = {
  orders: Order[];
  isLoading: boolean;
  fetchOrders: (supabase: SupabaseClient) => Promise<void>;
  addOrder: (supabase: SupabaseClient, orderData: NewOrderData) => Promise<Order | null>;
  addPayment: (supabase: SupabaseClient, orderId: string, amount: number, method: 'efectivo' | 'tarjeta' | 'transferencia') => Promise<void>;
  approveOrder: (supabase: SupabaseClient, data: { orderId: string, paymentMethod: Order['payment_method'], paymentDueDate?: Date, paymentReference?: string }) => Promise<void>;
  cancelOrder: (supabase: SupabaseClient, orderId: string) => Promise<void>;
  getOrderById: (orderId: string) => Order | undefined;
};

export const useOrdersStore = create<OrdersState>((set, get) => ({
  orders: [],
  isLoading: false,

  fetchOrders: async (supabase: SupabaseClient) => {
    set({ isLoading: true });
    try {
      const { data, error } = await supabase.from('orders').select('*').order('created_at', { ascending: false });
      if (error) throw error;
      set({ orders: data || [], isLoading: false });
    } catch (error: any) {
      toast({
        title: 'Error al cargar pedidos',
        description: error.message,
        variant: 'destructive',
      });
      set({ isLoading: false });
    }
  },

  addOrder: async (supabase, orderData) => {
    set({ isLoading: true });
    try {
      // Perform the insert without a select chain
      const { error, data } = await supabase.from('orders').insert([orderData]).select().single();
      
      if (error) {
        console.error("Supabase insert error:", error);
        throw error;
      }
       if (!data) {
        throw new Error("No data returned from Supabase after insert.");
      }

      // Instead of manually adding to state, re-fetch all orders to ensure consistency
      await get().fetchOrders(supabase);
      
      // Find and return the newly created order from the updated state
      const newOrder = get().orders.find(o => o.display_id === data.display_id);
      return newOrder || null;

    } catch (error: any) {
       toast({
        title: 'Error al crear pedido',
        description: error.message,
        variant: 'destructive',
      });
      return null;
    } finally {
       set({ isLoading: false });
    }
  },

  addPayment: async (supabase, orderId, amount, method) => {
    const order = get().orders.find(o => o.id === orderId);
    if (!order) return;
    
    const newBalance = order.balance - amount;
    const newPayment: Payment = {
        amount,
        method,
        date: new Date().toISOString(),
    };
    const updatedPayments = [...order.payments, newPayment];
    const newStatus = newBalance <= 0 ? 'paid' : 'pending-payment';

    try {
        const { data, error } = await supabase
            .from('orders')
            .update({ balance: newBalance, payments: updatedPayments, status: newStatus })
            .eq('id', orderId)
            .select()
            .single();

        if (error) throw error;
        
        set((state) => ({
            orders: state.orders.map((o) => (o.id === orderId ? data : o)),
        }));
    } catch (error: any) {
         toast({
            title: 'Error al registrar pago',
            description: error.message,
            variant: 'destructive',
        });
    }
  },

  approveOrder: async (supabase, { orderId, paymentMethod, paymentDueDate, paymentReference }) => {
    const order = get().orders.find(o => o.id === orderId);
    if (!order || order.status !== 'pending-approval') return;
    
    const isCredit = paymentMethod === 'credito';
    const isPaid = ['tarjeta', 'efectivo', 'transferencia'].includes(paymentMethod);
    
    let status: Order['status'] = 'pending-approval';
    if (isCredit) status = 'pending-payment';
    if (isPaid) status = 'paid';

    const updateData = {
        payment_method: paymentMethod,
        payment_due_date: paymentDueDate ? paymentDueDate.toISOString() : order.payment_due_date,
        payment_reference: paymentReference || order.payment_reference,
        status: status,
        balance: isCredit ? order.total : 0,
        payments: isPaid ? [{
            amount: order.total,
            date: new Date().toISOString(),
            method: paymentMethod as 'efectivo' | 'tarjeta' | 'transferencia'
        }] : [],
    };

    try {
        const { data, error } = await supabase.from('orders').update(updateData).eq('id', orderId).select().single();
        if (error) throw error;
        set((state) => ({
            orders: state.orders.map((o) => (o.id === orderId ? data : o)),
        }));
    } catch (error: any) {
         toast({
            title: 'Error al aprobar pedido',
            description: error.message,
            variant: 'destructive',
        });
    }
  },

  cancelOrder: async (supabase, orderId) => {
    try {
        const { data, error } = await supabase.from('orders').update({ status: 'cancelled' }).eq('id', orderId).select().single();
        if (error) throw error;
        set((state) => ({
            orders: state.orders.map((o) => (o.id === orderId ? data : o)),
        }));
    } catch (error: any) {
        toast({
            title: 'Error al cancelar pedido',
            description: error.message,
            variant: 'destructive',
        });
    }
  },

  getOrderById: (orderId: string) => {
    const order = get().orders.find((o) => o.display_id === orderId || o.id === orderId);
    return order;
  },
}));
